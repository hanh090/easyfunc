<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>keytool-Key and Certificate Management Tool</title>
<meta name="collection" content="reference" />
<meta name="copyright" content="1998-2011 keytool tool" /><link rel="stylesheet" href="../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>keytool - Key and Certificate Management Tool</h1>
<p>Manages a keystore (database) of cryptographic keys, X.509
certificate chains, and trusted certificates.</p>
<h2>SYNOPSIS</h2>
<pre class="codeblock">
<strong>keytool</strong> [ <a href="#Commands">commands</a> ]
</pre>
<p>The keytool command interface has changed in Java SE 6. See the
<a href="#Changes">Changes</a> Section for a detailed description.
Note that previously defined commands are still supported.</p>
<h2>DESCRIPTION</h2>
<b>keytool</b> is a key and certificate management utility. It
allows users to administer their own public/private key pairs and
associated certificates for use in self-authentication (where the
user authenticates himself/herself to other users/services) or data
integrity and authentication services, using digital signatures. It
also allows users to cache the public keys (in the form of
certificates) of their communicating peers.
<p>A <i>certificate</i> is a digitally signed statement from one
entity (person, company, etc.), saying that the public key (and
some other information) of some other entity has a particular
value. (See <a href="#Certificates">Certificates</a>.) When data is
digitally signed, the signature can be verified to check the data
integrity and authenticity. <i>Integrity</i> means that the data
has not been modified or tampered with, and <i>authenticity</i>
means the data indeed comes from whoever claims to have created and
signed it.</p>
<p><b>keytool</b> also enables users to administer secret keys used
in symmetric encryption/decryption (e.g. DES).</p>
<p><b>keytool</b> stores the keys and certificates in a <a href=
"#KeyStore"><i>keystore</i></a>.</p>
<h2><a name="CommandNotes" id="CommandNotes">COMMAND AND OPTION
NOTES</a></h2>
<p>The various commands and their options are listed and described
<a href="#Commands">below</a>. Note:</p>
<ul>
<li>All command and option names are preceded by a minus sign
(-).</li>
<li>The options for each command may be provided in any order.</li>
<li>All items not italicized or in braces or square brackets are
required to appear as is.</li>
<li>Braces surrounding an option generally signify that a <a href=
"#OptionDefaults">default</a> value will be used if the option is
not specified on the command line. Braces are also used around the
<code>-v</code>, <code>-rfc</code>, and <code>-J</code> options,
which only have meaning if they appear on the command line (that
is, they don't have any "default" values other than not
existing).</li>
<li>Brackets surrounding an option signify that the user is
prompted for the value(s) if the option is not specified on the
command line. (For a <code>-keypass</code> option, if you do not
specify the option on the command line, <b>keytool</b> will first
attempt to use the keystore password to recover the private/secret
key, and if this fails, will then prompt you for the private/secret
key password.)</li>
<li>Items in italics (option values) represent the actual values
that must be supplied. For example, here is the format of the
<code>-printcert</code> command:
<pre class="codeblock">
  keytool -printcert {-file <i>cert_file</i>} {-v}
</pre>
<p>When specifying a <code>-printcert</code> command, replace
<i>cert_file</i> with the actual file name, as in:</p>
<pre class="codeblock">
  keytool -printcert -file VScert.cer
</pre></li>
<li>Option values must be quoted if they contain a blank
(space).</li>
<li>The <code>-help</code> command is the default. Thus, the
command line
<pre class="codeblock">
  keytool
</pre>
<p>is equivalent to</p>
<pre class="codeblock">
  keytool -help
</pre></li>
</ul>
<h3><a name="OptionDefaults" id="OptionDefaults">Option
Defaults</a></h3>
<p>Below are the defaults for various option values.</p>
<pre class="codeblock">
-alias "mykey"

-keyalg
    "DSA" (when using <a href="#genkeypairCmd">-genkeypair</a>)
    "DES" (when using <a href="#genseckeyCmd">-genseckey</a>)

-keysize
    2048 (when using <a href=
"#genkeypairCmd">-genkeypair</a> and -keyalg is "RSA")
    1024 (when using <a href=
"#genkeypairCmd">-genkeypair</a> and -keyalg is "DSA")
    256 (when using <a href=
"#genseckeyCmd">-genkeypair</a> and -keyalg is "EC")
    56 (when using <a href=
"#genseckeyCmd">-genseckey</a> and -keyalg is "DES")
    168 (when using <a href=
"#genseckeyCmd">-genseckey</a> and -keyalg is "DESede")


-validity 90

-keystore the file named <code>.keystore</code> in the user's home directory

-storetype the value of the "keystore.type" property in the security properties file,
           which is returned by the static <code>getDefaultType</code> method in
           <code>java.security.KeyStore</code>

-file stdin if reading, stdout if writing

-protected false
</pre>
<p>In generating a public/private key pair, the signature algorithm
(<i>-sigalg</i> option) is derived from the algorithm of the
underlying private key:</p>
<ul>
<li>If the underlying private key is of type "DSA", the
<i>-sigalg</i> option defaults to "SHA1withDSA"</li>
<li>If the underlying private key is of type "RSA", the
<i>-sigalg</i> option defaults to "SHA256withRSA".</li>
<li>If the underlying private key is of type "EC", the
<i>-sigalg</i> option defaults to "SHA256withECDSA".</li>
</ul>
<p>Please consult the <a href=
"../../guides/security/crypto/CryptoSpec.html#AppA">Java
Cryptography Architecture API Specification &amp; Reference</a> for
a full list of <i>-keyalg</i> and <i>-sigalg</i> you can choose
from.</p>
<h3><a name="OptionsInAll" id="OptionsInAll">Common
Options</a></h3>
<p>The <code>-v</code> option can appear for all commands except
<code>-help</code>. If it appears, it signifies "verbose" mode;
more information will be provided in the output.</p>
<p>There is also a <code>-J<i>javaoption</i></code> option that may
appear for any command. If it appears, the specified
<i>javaoption</i> string is passed through directly to the Java
interpreter. This option should not contain any spaces. It is
useful for adjusting the execution environment or memory usage. For
a list of possible interpreter options, type <code>java -h</code>
or <code>java -X</code> at the command line.</p>
<p>These options may appear for all commands operating on a
keystore:</p>
<dl>
<dt><code>-storetype <i>storetype</i></code></dt>
<dd>
<p>This qualifier specifies the type of keystore to be
instantiated.</p>
</dd>
<dt><code>-keystore <i>keystore</i></code></dt>
<dd>
<p>The keystore location.</p>
<p>If the JKS <a href="#KeyStoreImplementation">storetype</a> is
used and a keystore file does not yet exist, then certain
<b>keytool</b> commands may result in a new keystore file being
created. For example, if <code>keytool -genkeypair</code> is
invoked and the <code>-keystore</code> option is not specified, the
default keystore file named <code>.keystore</code> in the user's
home directory will be created if it does not already exist.
Similarly, if the <code>-keystore <i>ks_file</i></code> option is
specified but <i>ks_file</i> does not exist, then it will be
created</p>
<p>Note that the input stream from the <code>-keystore</code>
option is passed to the <code>KeyStore.load</code> method. If
<code>NONE</code> is specified as the URL, then a null stream is
passed to the <code>KeyStore.load</code> method. <code>NONE</code>
should be specified if the <code>KeyStore</code> is not file-based
(for example, if it resides on a hardware token device).</p>
</dd>
<dt><code>-storepass</code>[<code>:env</code>|<code>:file</code>]
<em>argument</em></dt>
<dd>
<p>The password which is used to protect the integrity of the
keystore.</p>
<p>If the modifier <code>env</code> or <code>file</code> is not
specified, then the password has the value <i>argument</i>, which
must be at least 6 characters long. Otherwise, the password is
retrieved as follows:</p>
<ul>
<li><code>env</code>: Retrieve the password from the environment
variable named <i>argument</i></li>
<li><code>file</code>: Retrieve the password from the file named
<i>argument</i></li>
</ul>
<p><strong>Note</strong>: All other options that require passwords,
such as <code>-keypass</code>, <code>-srckeypass</code>,
<code>-destkeypass</code> <code>-srcstorepass</code>, and
<code>-deststorepass</code>, accept the <code>env</code> and
<code>file</code> modifiers. (Remember to separate the password
option and the modifier with a colon, (<code>:</code>).)</p>
<p>The password must be provided to all commands that access the
keystore contents. For such commands, if a <code>-storepass</code>
option is not provided at the command line, the user is prompted
for it.</p>
<p>When retrieving information from the keystore, the password is
optional; if no password is given, the integrity of the retrieved
information cannot be checked and a warning is displayed.</p>
</dd>
<dt><code>-providerName <i>provider_name</i></code></dt>
<dd>
<p>Used to identify a cryptographic service provider's name when
listed in the security properties file.</p>
</dd>
<dt><code>-providerClass <i>provider_class_name</i></code></dt>
<dd>
<p>Used to specify the name of cryptographic service provider's
master class file when the service provider is not listed in the
security properties file.</p>
</dd>
<dt><code>-providerArg <i>provider_arg</i></code></dt>
<dd>
<p>Used in conjunction with <code>-providerClass</code>. Represents
an optional string input argument for the constructor of
<i>provider_class_name</i>.</p>
</dd>
<dt><code>-protected</code></dt>
<dd>
<p>Either <code>true</code> or <code>false</code>. This value
should be specified as <code>true</code> if a password must be
given via a protected authentication path such as a dedicated PIN
reader.</p>
<p>Note: Since there are two keystores involved in
<code>-importkeystore</code> command, two options, namely,
<code>-srcprotected</code> and <code>-destprotected</code> are
provided for the source keystore and the destination keystore
respectively.</p>
</dd>
<dt><code>-ext <i>{name{:critical}{=value}}</i></code></dt>
<dd>
<p>Denotes an X.509 certificate extension. The option can be used
in -genkeypair and -gencert to embed extensions into the
certificate generated, or in <code>-certreq</code> to show what
extensions are requested in the certificate request. The option can
appear multiple times. name can be a supported extension name (see
below) or an arbitrary OID number. value, if provided, denotes the
parameter for the extension; if omitted, denotes the default value
(if defined) of the extension or the extension requires no
parameter. The <code>:critical</code> modifier, if provided, means
the extension's isCritical attribute is true; otherwise, false. You
may use <code>:c</code> in place of <code>:critical</code>.</p>
</dd>
</dl>
<p>Currently keytool supports these named extensions
(case-insensitive):</p>
<table width="458" border="1" summary="Named extensions">
<tr>
<th>Name</th>
<th>Value</th>
</tr>
<tr>
<td>BC or BasicConstraints</td>
<td>The full form:
&quot;ca:{true|false}[,pathlen:&lt;len&gt;]&quot;; or, &lt;len&gt;,
a shorthand for &quot;ca:true,pathlen:&lt;len&gt;&quot;;<br />
or omitted, means &quot;ca:true&quot;</td>
</tr>
<tr>
<td>KU or KeyUsage</td>
<td>usage(,usage)*, usage can be one of digitalSignature,<br />
nonRepudiation (contentCommitment), keyEncipherment,
dataEncipherment, keyAgreement, keyCertSign, cRLSign, encipherOnly,
decipherOnly. Usage can be abbreviated with the first few letters
(say, dig for digitalSignature) or in camel-case style (say,<br />
dS for digitalSignature, cRLS for cRLSign), as long as<br />
no ambiguity is found. Usage is case-insensitive.</td>
</tr>
<tr>
<td>EKU or ExtendedkeyUsage</td>
<td>usage(,usage)*, usage can be one of anyExtendedKeyUsage,<br />
serverAuth, clientAuth, codeSigning, emailProtection,<br />
timeStamping, OCSPSigning, or any OID string.<br />
Named usage can be abbreviated with the first<br />
few letters or in camel-case style, as long as<br />
no ambiguity is found. Usage is case-insensitive.</td>
</tr>
<tr>
<td>SAN or SubjectAlternativeName</td>
<td>type:value(,type:value)*, type can be EMAIL, URI, DNS, IP, or
OID, value is the string format value for the type.</td>
</tr>
<tr>
<td>IAN or IssuerAlternativeName</td>
<td>same as SubjectAlternativeName</td>
</tr>
<tr>
<td>SIA or SubjectInfoAccess</td>
<td>method:location-type:location-value<br />
(,method:location-type:location-value)*,<br />
method can be &quot;timeStamping&quot;, &quot;caRepository&quot; or
any OID. location-type and location-value can be any type:value
supported by the SubjectAlternativeName extension.</td>
</tr>
<tr>
<td>AIA or AuthorityInfoAccess</td>
<td>same as SubjectInfoAccess. method can be
&quot;ocsp&quot;,&quot;caIssuers&quot; or any OID.</td>
</tr>
</table>
<p>For name as OID, value is the HEX dumped DER encoding of the
extnValue for the extension excluding the OCTET STRING type and
length bytes. Any extra character other than standard HEX numbers
(0-9, a-f, A-F) are ignored in the HEX string. Therefore, both
<code>"01:02:03:04"</code> and <code>"01020304"</code> are accepted
as identical values. If there is no value, the extension has an
empty value field then.</p>
<p>A special name <code>'honored'</code>, used in
<code>-gencert</code> only, denotes how the extensions included in
the certificate request should be honored. The value for this name
is a comma separated list of <code>"all"</code> (all requested
extensions are honored),
<code>"name{:[critical|non-critical]}"</code> (the named extension
is honored, but using a different isCritical attribute) and
<code>"-name"</code> (used with all, denotes an exception).
Requested extensions are not honored by default.</p>
<p>If, besides the -ext honored option, another named or OID -ext
option is provided, this extension will be added to those already
honored. However, if this name (or OID) also appears in the honored
value, its value and criticality overrides the one in the
request.</p>
<p>The subjectKeyIdentifier extension is always created. For non
self-signed certificates, the authorityKeyIdentifier is always
created.</p>
<p><b>Note:</b> Users should be aware that some combinations of
extensions (and other certificate fields) may not conform to the
Internet standard. See <a href="#gencertwarning">Warning Regarding
Certificate Conformance</a> for details.</p>
<h2><a name="Commands" id="Commands">COMMANDS</a></h2>
<h3>Creating or Adding Data to the Keystore</h3>
<dl>
<dt><code><b><a name="gencertCmd" id="gencertCmd">-gencert</a></b>
{-rfc} {-infile <i>infile</i>} {-outfile <i>outfile</i>} {-alias
<i>alias</i>} {-sigalg <i>sigalg</i>} {-dname <i>dname</i>}
{-startdate <i>startdate</i> {-ext <i>ext</i>}* {-validity
<i>valDays</i>} [-keypass <i>keypass</i>] {-keystore
<i>keystore</i>} [-storepass <i>storepass</i>] {-storetype
<i>storetype</i>} {-providername <em>provider_name</em>}
{-providerClass <i>provider_class_name</i> {-providerArg
<i>provider_arg</i>}} {-v} {-protected}
{-J<i>javaoption</i>}</code></dt>
<dd>
<p>Generates a certificate as a response to a certificate request
file (which can be created by the <code>keytool -certreq</code>
command). The command reads the request from <em>infile</em> (if
omitted, from the standard input), signs it using alias's private
key, and output the X.509 certificate into <em>outfile</em> (if
omitted, to the standard output). If <code>-rfc</code> is
specified, output format is BASE64-encoded PEM; otherwise, a binary
DER is created.</p>
<p><em>sigalg</em> specifies the algorithm that should be used to
sign the certificate. <em>startdate</em> is the start time/date
that the certificate is valid. <em>valDays</em> tells the number of
days for which the certificate should be considered valid.</p>
<p>If <em>dname</em> is provided, it's used as the subject of the
generated certificate. Otherwise, the one from the certificate
request is used.</p>
<p><em>ext</em> shows what X.509 extensions will be embedded in the
certificate. Read Common Options for the grammar of
<code>-ext</code>.</p>
<p>The <code>-gencert</code> command enables you to create
certificate chains. The following example creates a certificate,
<code>e1</code>, that contains three certificates in its
certificate chain.</p>
<p>The following commands creates four key pairs named
<code>ca</code>, <code>ca1</code>, <code>ca2</code>, and
<code>e1</code>:</p>
<pre class="codeblock">
keytool -alias ca -dname CN=CA -genkeypair
keytool -alias ca1 -dname CN=CA -genkeypair
keytool -alias ca2 -dname CN=CA -genkeypair
keytool -alias e1 -dname CN=E1 -genkeypair
</pre>
<p>The following two commands create a chain of signed
certificates; <code>ca</code> signs ca1 and <code>ca1 signs
ca2</code>, all of which are self-issued:</p>
<pre class="codeblock">
keytool -alias ca1 -certreq | keytool -alias ca -gencert -ext san=dns:ca1 | keytool -alias ca1 -importcert
keytool -alias ca2 -certreq | $KT -alias ca1 -gencert -ext san=dns:ca2 | $KT -alias ca2 -importcert
</pre>
<p>The following command creates the certificate <code>e1</code>
and stores it in the file <code>e1.cert</code>, which is signed by
<code>ca2</code>. As a result, <code>e1</code> should contain
<code>ca</code>, <code>ca1</code>, and <code>ca2</code> in its
certificate chain:</p>
<pre class="codeblock">
keytool -alias e1 -certreq | keytool -alias ca2 -gencert &gt; e1.cert
</pre></dd>
<dt><code><b><a name="genkeypairCmd" id=
"genkeypairCmd">-genkeypair</a></b> {-alias <i>alias</i>} {-keyalg
<i>keyalg</i>} {-keysize <i>keysize</i>} {-sigalg <i>sigalg</i>}
[-dname <i>dname</i>] [-keypass <i>keypass</i>] {-startdate
<em>value</em>} {-ext <i>ext</i>}* {-validity <i>valDays</i>}
{-storetype <i>storetype</i>} {-keystore <i>keystore</i>}
[-storepass <i>storepass</i>] {-providerClass
<i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v}
{-protected} {-J<i>javaoption</i>}</code></dt>
<dd>
<p>Generates a key pair (a public key and associated private key).
Wraps the public key into an X.509 v3 self-signed certificate,
which is stored as a single-element certificate chain. This
certificate chain and the private key are stored in a new keystore
entry identified by <em>alias</em>.</p>
<p><em>keyalg</em> specifies the algorithm to be used to generate
the key pair, and <em>keysize</em> specifies the size of each key
to be generated. <em>sigalg</em> specifies the algorithm that
should be used to sign the self-signed certificate; this algorithm
must be compatible with <em>keyalg</em>.</p>
<p><em>dname</em> specifies the <a href="#DName">X.500
Distinguished Name</a> to be associated with <em>alias</em>, and is
used as the <code>issuer</code> and <code>subject</code> fields in
the self-signed certificate. If no distinguished name is provided
at the command line, the user will be prompted for one.</p>
<p><em>keypass</em> is a password used to protect the private key
of the generated key pair. If no password is provided, the user is
prompted for it. If you press RETURN at the prompt, the key
password is set to the same password as that used for the keystore.
<em>keypass</em> must be at least 6 characters long.</p>
<p><em>startdate</em> specifies the issue time of the certificate,
also known as the "Not Before" value of the X.509 certificate's
Validity field.</p>
<p>The option value can be set in one of these two forms:</p>
<ol>
<li>([+-]<i>nnn</i>[ymdHMS])+</li>
<li>[yyyy/mm/dd] [HH:MM:SS]</li>
</ol>
<p>With the first form, the issue time is shifted by the specified
value from the current time. The value is a concatenation of a
sequence of sub values. Inside each sub value, the plus sign ("+")
means shifting forward, and the minus sign ("-") means shifting
backward. The time to be shifted is <i>nnn</i> units of years,
months, days, hours, minutes, or seconds (denoted by a single
character of "y", "m", "d", "H", "M", or "S" respectively). The
exact value of the issue time is calculated using the
<code>java.util.GregorianCalendar.add(int field, int amount)</code>
method on each sub value, from left to right. For example, by
specifying <code>"-startdate -1y+1m-1d"</code>, the issue time will
be:</p>
<pre class="codeblock">
   Calendar c = new GregorianCalendar();
   c.add(Calendar.YEAR, -1);
   c.add(Calendar.MONTH, 1);
   c.add(Calendar.DATE, -1);
   return c.getTime()
</pre>
<p>With the second form, the user sets the exact issue time in two
parts, year/month/day and hour:minute:second (using the local time
zone). The user may provide only one part, which means the other
part is the same as the current date (or time). User must provide
the exact number of digits as shown in the format definition
(padding with 0 if shorter). When both the date and time are
provided, there is one (and only one) space character between the
two parts. The hour should always be provided in 24 hour
format.</p>
<p>When the option is not provided, the start date is the current
time. The option can be provided at most once.</p>
<p><em>valDays</em> specifies the number of days (starting at the
date specified by <code>-startdate</code>, or the current date if
<code>-startdate</code> is not specified) for which the certificate
should be considered valid.</p>
<p>This command was named <tt>-genkey</tt> in previous releases.
This old name is still supported in this release and will be
supported in future releases, but for clarity the new name,
<tt>-genkeypair</tt>, is preferred going forward.</p>
</dd>
<dt><code><b><a name="genseckeyCmd" id=
"genseckeyCmd">-genseckey</a></b> {-alias <i>alias</i>} {-keyalg
<i>keyalg</i>} {-keysize <i>keysize</i>} [-keypass <i>keypass</i>]
{-storetype <i>storetype</i>} {-keystore <i>keystore</i>}
[-storepass <i>storepass</i>] {-providerClass
<i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v}
{-protected} {-J<i>javaoption</i>}</code></dt>
<dd>
<p>Generates a secret key and stores it in a new
<code>KeyStore.SecretKeyEntry</code> identified by
<em>alias</em>.</p>
<p><em>keyalg</em> specifies the algorithm to be used to generate
the secret key, and <em>keysize</em> specifies the size of the key
to be generated. <em>keypass</em> is a password used to protect the
secret key. If no password is provided, the user is prompted for
it. If you press RETURN at the prompt, the key password is set to
the same password as that used for the keystore. <em>keypass</em>
must be at least 6 characters long.</p>
</dd>
<dt><code><b><a name="importCertCmd" id=
"importCertCmd">-importcert</a></b> {-alias <i>alias</i>} {-file
<i>cert_file</i>} [-keypass <i>keypass</i>] {-noprompt}
{-trustcacerts} {-storetype <i>storetype</i>} {-keystore
<i>keystore</i>} [-storepass <i>storepass</i>] {-providerName
<i>provider_name</i>} {-providerClass <i>provider_class_name</i>
{-providerArg <i>provider_arg</i>}} {-v} {-protected}
{-J<i>javaoption</i>}</code></dt>
<dd>
<p>Reads the certificate or certificate chain (where the latter is
supplied in a PKCS#7 formatted reply or a sequence of X.509
certificates) from the file <i>cert_file</i>, and stores it in the
keystore entry identified by <i>alias</i>. If no file is given, the
certificate or certificate chain is read from stdin.</p>
<p><b>keytool</b> can import X.509 v1, v2, and v3 certificates, and
PKCS#7 formatted certificate chains consisting of certificates of
that type. The data to be imported must be provided either in
binary encoding format, or in printable encoding format (also known
as Base64 encoding) as defined by the <a href=
"#EncodeCertificate">Internet RFC 1421 standard</a>. In the latter
case, the encoding must be bounded at the beginning by a string
that starts with "-----BEGIN", and bounded at the end by a string
that starts with "-----END".</p>
<p>You import a certificate for two reasons:</p>
<ol>
<li>to add it to the list of trusted certificates, or</li>
<li>to import a certificate reply received from a CA as the result
of submitting a Certificate Signing Request (see the <a href=
"#certreqCmd">-certreq</a> command) to that CA.</li>
</ol>
<p>Which type of import is intended is indicated by the value of
the <code>-alias</code> option:</p>
<ol>
<li><b>If the alias does not point to a key entry</b>, then
<b>keytool</b> assumes you are adding a trusted certificate entry.
In this case, the alias should not already exist in the keystore.
If the alias does already exist, then <b>keytool</b> outputs an
error, since there is already a trusted certificate for that alias,
and does not import the certificate.</li>
<li>
<p><b>If the alias points to a key entry</b>, then <b>keytool</b>
assumes you are importing a certificate reply.</p>
</li>
</ol>
<h4>Importing a New Trusted Certificate</h4>
<p>Before adding the certificate to the keystore, <b>keytool</b>
tries to verify it by attempting to construct a chain of trust from
that certificate to a self-signed certificate (belonging to a root
CA), using trusted certificates that are already available in the
keystore.</p>
<p>If the <code>-trustcacerts</code> option has been specified,
additional certificates are considered for the chain of trust,
namely the certificates in a <a href="#cacerts">file named
"cacerts"</a>.</p>
<p>If <b>keytool</b> fails to establish a trust path from the
certificate to be imported up to a self-signed certificate (either
from the keystore or the "cacerts" file), the certificate
information is printed out, and the user is prompted to verify it,
e.g., by comparing the displayed certificate fingerprints with the
fingerprints obtained from some other (trusted) source of
information, which might be the certificate owner himself/herself.
Be very careful to ensure the certificate is valid prior to
importing it as a "trusted" certificate! -- see <a href=
"#TrustedCertWarning">WARNING Regarding Importing Trusted
Certificates</a>. The user then has the option of aborting the
import operation. If the <code>-noprompt</code> option is given,
however, there will be no interaction with the user.</p>
<h4>Importing a Certificate Reply</h4>
<p>When importing a certificate reply, the certificate reply is
validated using trusted certificates from the keystore, and
optionally using the certificates configured in the <a href=
"#cacerts">"cacerts" keystore file</a> (if the
<code>-trustcacerts</code> option was specified).</p>
<p>The methods of determining whether the certificate reply is
trusted are described in the following:</p>
<ul>
<li><b>If the reply is a single X.509 certificate</b>,
<b>keytool</b> attempts to establish a trust chain, starting at the
certificate reply and ending at a self-signed certificate
(belonging to a root CA). The certificate reply and the hierarchy
of certificates used to authenticate the certificate reply form the
new certificate chain of <i>alias</i>. If a trust chain cannot be
established, the certificate reply is not imported. In this case,
<b>keytool</b> does not print out the certificate and prompt the
user to verify it, because it is very hard (if not impossible) for
a user to determine the authenticity of the certificate reply.</li>
<li><b>If the reply is a PKCS#7 formatted certificate chain or a
sequence of X.509 certificates</b>, the chain is ordered with the
user certificate first followed by zero or more CA certificates. If
the chain ends with a self-signed root CA certificate and
<code>-trustcacerts</code> option was specified, <b>keytool</b>
will attempt to match it with any of the trusted certificates in
the keystore or the "cacerts" keystore file. If the chain does not
end with a self-signed root CA certificate and the
<code>-trustcacerts</code> option was specified, <b>keytool</b>
will try to find one from the trusted certificates in the keystore
or the "cacerts" keystore file and add it to the end of the chain.
If the certificate is not found and <code>-noprompt</code> option
is not specified, the information of the last certificate in the
chain is printed out, and the user is prompted to verify it.</li>
</ul>
<p>If the public key in the certificate reply matches the user's
public key already stored with under <i>alias</i>, the old
certificate chain is replaced with the new certificate chain in the
reply. The old chain can only be replaced if a valid
<i>keypass</i>, the password used to protect the private key of the
entry, is supplied. If no password is provided, and the private key
password is different from the keystore password, the user is
prompted for it.</p>
<p>This command was named <tt>-import</tt> in previous releases.
This old name is still supported in this release and will be
supported in future releases, but for clarify the new name,
<tt>-importcert</tt>, is preferred going forward.</p>
</dd>
<!--dt><code><b><a name="selfcertCmd">-selfcert </a></b>
  {-alias <i>alias</i>}
  {-sigalg <i>sigalg</i>} {-dname <i>dname</i>}
  {-validity <i>valDays</i>} [-keypass <i>keypass</i>]
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Generates an X.509 v3 self-signed certificate,
using keystore information including the private key and
public key associated with <em>alias</em>. If <i>dname</i> is
supplied at the command line, it is used as the
<a href="#DName">X.500 Distinguished Name</a> for
both the <code>issuer</code> and <code>subject</code> of the
certificate. Otherwise, the X.500 Distinguished Name associated
with <em>alias</em> (at the bottom of its existing certificate
chain) is used.

</p><p>The generated certificate is stored as a single-element certificate chain
in the keystore entry identified by <em>alias</em>, where it replaces the
existing certificate chain.

</p><p><em>sigalg</em> specifies the algorithm that should be used to
sign the certificate.

</p><p>In order to access the private key, the appropriate password must be
provided, since private keys
are protected in the keystore with a password. If <em>keypass</em> is not
provided at the command line, and is different from the password used to
protect the integrity of the keystore, the user is prompted for it.

</p><p><em>valDays</em> tells the number of days for which the certificate
should be considered valid.</p></dd-->
<!--dt><code><b><a name="identitydbCmd">-identitydb </a></b>
  {-file <i>idb_file</i>}
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Reads the JDK 1.1.x-style identity database from the file
<em>idb_file</em>, and adds its entries to the keystore.
If no file is given, the identity database is read from stdin.
If a keystore does not exist, it is created.

</p><p>Only identity database entries ("identities") that were marked as
trusted will
be imported in the keystore. All other identities will be ignored.
For each trusted identity, a keystore entry will be created.
The identity's name is used as the "alias" for the keystore entry.

</p><p>The private keys from trusted identities will all be encrypted
under the same password, <i>storepass</i>. This is the same password that
is used to protect the keystore's integrity.
Users can later assign individual passwords to those private keys
by using the "-keypasswd" <b>keytool</b> command option.

</p><p>An identity in an identity database may hold more than one
certificate, each certifying the same public key. But a keystore
key entry for a private key has that private key and
a single "certificate chain" (initially just a single certificate),
where the first certificate in the chain
contains the public key corresponding to the private key.
When importing the information from an identity, only the first
certificate of the identity is stored in the keystore.
This is because an identity's name in an
identity database is used as the alias for
its corresponding keystore entry, and alias names are unique
within a keystore,


</p></dd-->
<dt><code><b><a name="importKeyStoreCmd" id=
"importKeyStoreCmd">-importkeystore</a></b> -srckeystore
<i>srckeystore</i> -destkeystore <i>destkeystore</i> {-srcstoretype
<i>srcstoretype</i>} {-deststoretype <i>deststoretype</i>}
[-srcstorepass <i>srcstorepass</i>] [-deststorepass
<i>deststorepass</i>] {-srcprotected} {-destprotected} {-srcalias
<i>srcalias</i> {-destalias <i>destalias</i>} [-srckeypass
<i>srckeypass</i>] [-destkeypass <i>destkeypass</i>] } {-noprompt}
{-srcProviderName <i>src_provider_name</i>} {-destProviderName
<i>dest_provider_name</i>} {-providerClass
<i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v}
{-protected} {-J<i>javaoption</i>}</code></dt>
<dd>
<p>Imports a single entry or all entries from a source keystore to
a destination keystore.</p>
<p>When the <em>srcalias</em> option is provided, the command
imports the single entry identified by the alias to the destination
keystore. If a destination alias is not provided with
<em>destalias</em>, then <em>srcalias</em> is used as the
destination alias. If the source entry is protected by a password,
<em>srckeypass</em> will be used to recover the entry. If
<em>srckeypass</em> is not provided, then <b>keytool</b> will
attempt to use <em>srcstorepass</em> to recover the entry. If
<em>srcstorepass</em> is either not provided or is incorrect, the
user will be prompted for a password. The destination entry will be
protected using <em>destkeypass</em>. If <em>destkeypass</em> is
not provided, the destination entry will be protected with the
source entry password.</p>
<p>If the <em>srcalias</em> option is not provided, then all
entries in the source keystore are imported into the destination
keystore. Each destination entry will be stored under the alias
from the source entry. If the source entry is protected by a
password, <em>srcstorepass</em> will be used to recover the entry.
If <em>srcstorepass</em> is either not provided or is incorrect,
the user will be prompted for a password. If a source keystore
entry type is not supported in the destination keystore, or if an
error occurs while storing an entry into the destination keystore,
the user will be prompted whether to skip the entry and continue,
or to quit. The destination entry will be protected with the source
entry password.</p>
<p>If the destination alias already exists in the destination
keystore, the user is prompted to either overwrite the entry, or to
create a new entry under a different alias name.</p>
<p>Note that if <code>-noprompt</code> is provided, the user will
not be prompted for a new destination alias. Existing entries will
automatically be overwritten with the destination alias name.
Finally, entries that can not be imported are automatically skipped
and a warning is output.</p>
</dd>
<dt><code><b><a name="printcertreqCmd" id=
"printcertreqCmd">-printcertreq</a></b> {-file
<i>file</i>}</code></dt>
<dd>
<p>Prints the content of a PKCS #10 format certificate request,
which can be generated by the keytool -certreq command. The command
reads the request from file; if omitted, from the standard
input.</p>
</dd>
</dl>
<h3>Exporting Data</h3>
<dl>
<dt><code><b><a name="certreqCmd" id="certreqCmd">-certreq</a></b>
{-alias <i>alias</i>} {-dname <i>dname</i>} {-sigalg <i>sigalg</i>}
{-file <i>certreq_file</i>} [-keypass <i>keypass</i>] {-storetype
<i>storetype</i>} {-keystore <i>keystore</i>} [-storepass
<i>storepass</i>] {-providerName <i>provider_name</i>}
{-providerClass <i>provider_class_name</i> {-providerArg
<i>provider_arg</i>}} {-v} {-protected}
{-J<i>javaoption</i>}</code></dt>
<dd>
<p>Generates a Certificate Signing Request (CSR), using the PKCS#10
format.</p>
<p>A CSR is intended to be sent to a certificate authority (CA).
The CA will authenticate the certificate requestor (usually
off-line) and will return a certificate or certificate chain, used
to replace the existing certificate chain (which initially consists
of a self-signed certificate) in the keystore.</p>
<p>The private key associated with <em>alias</em> is used to create
the PKCS#10 certificate request. In order to access the private
key, the appropriate password must be provided, since private keys
are protected in the keystore with a password. If <em>keypass</em>
is not provided at the command line, and is different from the
password used to protect the integrity of the keystore, the user is
prompted for it. If dname is provided, it's used as the subject in
the CSR. Otherwise, the X.500 Distinguished Name associated with
alias is used.</p>
<p><em>sigalg</em> specifies the algorithm that should be used to
sign the CSR.</p>
<p>The CSR is stored in the file <em>certreq_file</em>. If no file
is given, the CSR is output to stdout.</p>
<p>Use the <em>importcert</em> command to import the response from
the CA.</p>
</dd>
<dt><code><b><a name="exportCertCmd" id=
"exportCertCmd">-exportcert</a></b> {-alias <i>alias</i>} {-file
<i>cert_file</i>} {-storetype <i>storetype</i>} {-keystore
<i>keystore</i>} [-storepass <i>storepass</i>] {-providerName
<i>provider_name</i>} {-providerClass <i>provider_class_name</i>
{-providerArg <i>provider_arg</i>}} {-rfc} {-v} {-protected}
{-J<i>javaoption</i>}</code></dt>
<dd>
<p>Reads (from the keystore) the certificate associated with
<em>alias</em>, and stores it in the file <em>cert_file</em>.</p>
<p>If no file is given, the certificate is output to stdout.</p>
<p>The certificate is by default output in binary encoding, but
will instead be output in the printable encoding format, as defined
by the <a href="#EncodeCertificate">Internet RFC 1421 standard</a>,
if the <code>-rfc</code> option is specified.</p>
<p>If <i>alias</i> refers to a trusted certificate, that
certificate is output. Otherwise, <i>alias</i> refers to a key
entry with an associated certificate chain. In that case, the first
certificate in the chain is returned. This certificate
authenticates the public key of the entity addressed by
<i>alias</i>.</p>
<p>This command was named <tt>-export</tt> in previous releases.
This old name is still supported in this release and will be
supported in future releases, but for clarify the new name,
<tt>-exportcert</tt>, is preferred going forward.</p>
</dd>
</dl>
<h3>Displaying Data</h3>
<dl>
<dt><code><b><a name="listCmd" id="listCmd">-list</a></b> {-alias
<i>alias</i>} {-storetype <i>storetype</i>} {-keystore
<i>keystore</i>} [-storepass <i>storepass</i>] {-providerName
<i>provider_name</i>} {-providerClass <i>provider_class_name</i>
{-providerArg <i>provider_arg</i>}} {-v | -rfc} {-protected}
{-J<i>javaoption</i>}</code></dt>
<dd>
<p>Prints (to stdout) the contents of the keystore entry identified
by <i>alias</i>. If no alias is specified, the contents of the
entire keystore are printed.</p>
<p>This command by default prints the SHA1 fingerprint of a
certificate. If the <code>-v</code> option is specified, the
certificate is printed in human-readable format, with additional
information such as the owner, issuer, serial number, and any
extensions. If the <code>-rfc</code> option is specified,
certificate contents are printed using the printable encoding
format, as defined by the <a href="#EncodeCertificate">Internet RFC
1421 standard</a></p>
<p>You cannot specify both <code>-v</code> and
<code>-rfc</code>.</p>
</dd>
<dt><code><b><a name="printcertCmd" id=
"printcertCmd">-printcert</a></b> {-file <i>cert_file</i> |
-sslserver host[:port]} {-jarfile <em>JAR_file</em> {-rfc} {-v}
{-J<i>javaoption</i>}</code></dt>
<dd>
<p>Reads the certificate from the file <em>cert_file</em>, the SSL
server located at <em>host:port</em>, or the signed JAR file
<em>JAR_file</em> (with the option <code>-jarfile</code> and prints
its contents in a human-readable format. When no port is specified,
the standard HTTPS port 443 is assumed. Note that
<code>-sslserver</code> and <code>-file</code> options cannot be
provided at the same time. Otherwise, an error is reported. If
neither option is given, the certificate is read from stdin.</p>
<p>If <code>-rfc</code> is specified, keytool prints the
certificate in PEM mode as defined by the Internet RFC 1421
standard.</p>
<p>If the certificate is read from a file or stdin, it may be
either binary encoded or in printable encoding format, as defined
by the <a href="#EncodeCertificate">Internet RFC 1421
standard</a></p>
<p>If the SSL server is behind a firewall,
<code>-J-Dhttps.proxyHost=proxyhost</code> and
<code>-J-Dhttps.proxyPort=proxyport</code> can be specified on the
command line for proxy tunneling. See the <a href=
"../../guides/security/jsse/JSSERefGuide.html">JSSE Reference
Guide</a> for more information.</p>
<p><b>Note</b>: This option can be used independently of a
keystore.</p>
</dd>
<dt><code><b><a name="printcrlCmd" id=
"printcrlCmd">-printcrl</a></b> -file <i>crl_</i> {-v}</code></dt>
<dd>
<p>Reads the certificate revocation list (CRL) from the file
<em>crl_file</em>.</p>
<p>A Certificate Revocation List (CRL) is a list of digital
certificates which have been revoked by the Certificate Authority
(CA) that issued them. The CA generates <em>crl_file</em>.</p>
<p><b>Note</b>: This option can be used independently of a
keystore.</p>
</dd>
</dl>
<h3>Managing the Keystore</h3>
<dl><!--dt><code><b><a name="keycloneCmd">-keyclone </a></b>
  {-alias <i>alias</i>}
  [-dest <i>dest_alias</i>]
  [-keypass <i>keypass</i>] [-new <i>new_keypass</i>]
  {-storetype <i>storetype</i>}
  {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]
  {-providerName <i>provider_name</i>}
  {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}
  {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>Creates a new keystore entry, which has the same private key and
certificate chain as the original entry if it's a private key entry, or has
the same secret key if it's a secret key entry.

</p><p>The original entry is identified by <em>alias</em> (which defaults
to "mykey" if not provided).
The new (destination) entry is identified by <em>dest_alias</em>.
If no destination alias is supplied at the command
line, the user is prompted for it.

</p><p>If the private/secret key password is different from the keystore password,
then the entry will only be cloned if a valid <i>keypass</i> is
supplied.  This is the password used to protect the key
associated with <i>alias</i>. If no key password is supplied at the command
line, and the key password is different from the keystore password,
the user is prompted for it.

The key in the cloned entry
may be protected with a different password, if desired. If no
<code>-new</code> option is supplied at the command line, the
user is prompted for the new entry's password (and may choose to
let it be the same as for the cloned entry's private/secret key).

</p></dd-->
<dt><code><b><a name="storePasswdCmd" id=
"storePasswdCmd">-storepasswd</a></b> [-new <i>new_storepass</i>]
{-storetype <i>storetype</i>} {-keystore <i>keystore</i>}
[-storepass <i>storepass</i>] {-providerName <i>provider_name</i>}
{-providerClass <i>provider_class_name</i> {-providerArg
<i>provider_arg</i>}} {-v} {-J<i>javaoption</i>}</code></dt>
<dd>
<p>Changes the password used to protect the integrity of the
keystore contents. The new password is <em>new_storepass</em>,
which must be at least 6 characters long.</p>
</dd>
<dt><code><b><a name="keyPasswdCmd" id=
"keyPasswdCmd">-keypasswd</a></b> {-alias <i>alias</i>} [-keypass
<i>old_keypass</i>] [-new <i>new_keypass</i>] {-storetype
<i>storetype</i>} {-keystore <i>keystore</i>} [-storepass
<i>storepass</i>] {-providerName <i>provider_name</i>}
{-providerClass <i>provider_class_name</i> {-providerArg
<i>provider_arg</i>}} {-v} {-J<i>javaoption</i>}</code></dt>
<dd>
<p>Changes the password under which the private/secret key
identified by <em>alias</em> is protected, from
<em>old_keypass</em> to <em>new_keypass</em>, which must be at
least 6 characters long.</p>
<p>If the <code>-keypass</code> option is not provided at the
command line, and the key password is different from the keystore
password, the user is prompted for it.</p>
<p>If the <code>-new</code> option is not provided at the command
line, the user is prompted for it.</p>
</dd>
<dt><code><b><a name="deleteCmd" id="deleteCmd">-delete</a></b>
[-alias <i>alias</i>] {-storetype <i>storetype</i>} {-keystore
<i>keystore</i>} [-storepass <i>storepass</i>] {-providerName
<i>provider_name</i>} {-providerClass <i>provider_class_name</i>
{-providerArg <i>provider_arg</i>}} {-v} {-protected}
{-J<i>javaoption</i>}</code></dt>
<dd>
<p>Deletes from the keystore the entry identified by
<em>alias</em>. The user is prompted for the alias, if no alias is
provided at the command line.</p>
</dd>
<dt><code><b><a name="changeAliasCmd" id=
"changeAliasCmd">-changealias</a></b> {-alias <i>alias</i>}
[-destalias <i>destalias</i>] [-keypass <i>keypass</i>] {-storetype
<i>storetype</i>} {-keystore <i>keystore</i>} [-storepass
<i>storepass</i>] {-providerName <i>provider_name</i>}
{-providerClass <i>provider_class_name</i> {-providerArg
<i>provider_arg</i>}} {-v} {-protected}
{-J<i>javaoption</i>}</code></dt>
<dd>
<p>Move an existing keystore entry from the specified
<em>alias</em> to a new alias, <em>destalias</em>. If no
destination alias is provided, the command will prompt for one. If
the original entry is protected with an entry password, the
password can be supplied via the "-keypass" option. If no key
password is provided, the <i>storepass</i> (if given) will be
attempted first. If that attempt fails, the user will be prompted
for a password.</p>
</dd>
</dl>
<h3>Getting Help</h3>
<dl>
<dt><code><b><a name="helpCmd" id=
"helpCmd">-help</a></b></code></dt>
<dd>
<p>Lists the basic commands and their options.</p>
<p>For more information about a specific command, enter the
following, where <code><em>command_name</em></code> is the name of
the command:</p>
<pre class="codeblock">
keytool -<em>command_name</em> -help
</pre></dd>
</dl>
<h2><a name="EXAMPLES" id="EXAMPLES">EXAMPLES</a></h2>
<p>Suppose you want to create a keystore for managing your
public/private key pair and certificates from entities you
trust.</p>
<!--
<h3>Generating a Secret Key</h3>

<p>You can always generate a secret key in a keystore so that it can be used by
a Java program later. The command is very simple:

</p>
<pre class="codeblock">
    keytool -genseckey -alias mysecret -keyalg DESede -keysize 112
      -keypass <em>&lt;password for private key&gt;</em> -keystore C:\working\mykeystore
      -storepass <em>&lt;password for keystore&gt;</em>
</pre>

<p>This command create a DESede type secret key (with key size 112) in a keystore
based on the file C:\working\mykeystore. The storepass <em>&lt;password for keystore&gt;</em> is needed to update
the keystore. The keypass <em>&lt;password for private key&gt;</em> is the protect password for the secret entry
itself. When the secret key is generated, it is stored as a KeyStore.SecretKeyEntry
in the key store which you can always use KeyStore.getKey() to retrieve.

</p><p>in order to see what kind of secret key you can create, you can refer to
<a href="../../technotes/guides/security/crypto/CryptoSpec.html#AppA">
http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA</a>
to see what keyalg you can provide. Please take attention that although the
above link is titled SunJCE Default keysizes, that does not garantee keytool
will recognize it, you are still required to provide the keysize option yourself.
</p>

-->
<!-- ****************** -->
<h3>Generating Your Key Pair</h3>
<p>The first thing you need to do is create a keystore and generate
the key pair. You could use a command such as the following:</p>
<pre class="codeblock">
    keytool -genkeypair -dname "cn=Mark Jones, ou=Java, o=Oracle, c=US"
      -alias business -keypass <em>&lt;new password for private key&gt;</em> -keystore /working/mykeystore
      -storepass <em>&lt;new password for keystore&gt;</em> -validity 180
</pre>
<!-- ********************* -->
<p>(Please note: This must be typed as a single line. Multiple
lines are used in the examples just for legibility purposes.)</p>
<p>This command creates the keystore named "mykeystore" in the
"working" directory (assuming it doesn't already exist), and
assigns it the password specified by <em>&lt;new password for keystore&gt;</em>. It generates a public/private key
pair for the entity whose "distinguished name" has a common name of
"Mark Jones", organizational unit of "Java", organization of
"Oracle" and two-letter country code of "US". It uses the default
"DSA" key generation algorithm to create the keys, both 1024 bits
long.</p>
<p>It creates a self-signed certificate (using the default
"SHA1withDSA" signature algorithm) that includes the public key and
the distinguished name information. This certificate will be valid
for 180 days, and is associated with the private key in a keystore
entry referred to by the alias "business". The private key is
assigned the password specified by <em>&lt;new password for private key&gt;</em>.</p>
<p>The command could be significantly shorter if option defaults
were accepted. As a matter of fact, no options are required;
defaults are used for unspecified options that have default values,
and you are prompted for any required values. Thus, you could
simply have the following:</p>
<pre class="codeblock">
    keytool -genkeypair
</pre>
<p>In this case, a keystore entry with alias "mykey" is created,
with a newly-generated key pair and a certificate that is valid for
90 days. This entry is placed in the keystore named ".keystore" in
your home directory. (The keystore is created if it doesn't already
exist.) You will be prompted for the distinguished name
information, the keystore password, and the private key
password.</p>
<p>The rest of the examples assume you executed the
<code>-genkeypair</code> command without options specified, and
that you responded to the prompts with values equal to those given
in the first <code>-genkeypair</code> command, above (for example, a distinguished name of "cn=Mark Jones, ou=Java, o=Oracle, c=US").</p>
<h3>Requesting a Signed Certificate from a Certification
Authority</h3>
<p>So far all we've got is a self-signed certificate. A certificate
is more likely to be trusted by others if it is signed by a
Certification Authority (CA). To get such a signature, you first
generate a Certificate Signing Request (CSR), via the
following:</p>
<pre class="codeblock">
    keytool -certreq -file MarkJ.csr
</pre>
<p>This creates a CSR (for the entity identified by the default
alias "mykey") and puts the request in the file named "MarkJ.csr".
Submit this file to a CA, such as VeriSign, Inc. The CA will
authenticate you, the requestor (usually off-line), and then will
return a certificate, signed by them, authenticating your public
key. (In some cases, they will actually return a chain of
certificates, each one authenticating the public key of the signer
of the previous certificate in the chain.)</p>
<h3>Importing a Certificate for the CA</h3>
<p>You need to replace your self-signed certificate with a
certificate chain, where each certificate in the chain
authenticates the public key of the signer of the previous
certificate in the chain, up to a "root" CA.</p>
<p>Before you import the certificate reply from a CA, you need one
or more "trusted certificates" in your keystore or in the
<code>cacerts</code> keystore file (which is described in <a href=
"#importCertCmd">importcert command</a>):</p>
<ul>
<li>If the certificate reply is a certificate chain, you just need
the top certificate of the chain (that is, the "root" CA
certificate authenticating that CA's public key).</li>
<li>If the certificate reply is a single certificate, you need a
certificate for the issuing CA (the one that signed it), and if
that certificate is not self-signed, you need a certificate for its
signer, and so on, up to a self-signed "root" CA certificate.</li>
</ul>
<p>The "cacerts" keystore file ships with several VeriSign root CA
certificates, so you probably won't need to import a VeriSign
certificate as a trusted certificate in your keystore. But if you
request a signed certificate from a different CA, and a certificate
authenticating that CA's public key hasn't been added to "cacerts",
you will need to import a certificate from the CA as a "trusted
certificate".</p>
<p>A certificate from a CA is usually either self-signed, or signed
by another CA (in which case you also need a certificate
authenticating that CA's public key). Suppose company ABC, Inc., is
a CA, and you obtain a file named "ABCCA.cer" that is purportedly a
self-signed certificate from ABC, authenticating that CA's public
key.</p>
<p>Be very careful to ensure the certificate is valid prior to
importing it as a "trusted" certificate! View it first (using the
<b>keytool</b> <code>-printcert</code> command, or the
<b>keytool</b> <code>-importcert</code> command without the
<code>-noprompt</code> option), and make sure that the displayed
certificate fingerprint(s) match the expected ones. You can call
the person who sent the certificate, and compare the fingerprint(s)
that you see with the ones that they show (or that a secure public
key repository shows). Only if the fingerprints are equal is it
guaranteed that the certificate has not been replaced in transit
with somebody else's (for example, an attacker's) certificate. If
such an attack took place, and you did not check the certificate
before you imported it, you would end up trusting anything the
attacker has signed.</p>
<p>If you trust that the certificate is valid, then you can add it
to your keystore via the following:</p>
<pre class="codeblock">
    keytool -importcert -alias abc -file ABCCA.cer
</pre>
<p>This creates a "trusted certificate" entry in the keystore, with
the data from the file "ABCCA.cer", and assigns the alias "abc" to
the entry.</p>
<h3>Importing the Certificate Reply from the CA</h3>
<p>Once you've imported a certificate authenticating the public key
of the CA you submitted your certificate signing request to (or
there is already such a certificate in the "cacerts" file), you can
import the certificate reply and thereby replace your self-signed
certificate with a certificate chain. This chain is the one
returned by the CA in response to your request (if the CA reply is
a chain), or one constructed (if the CA reply is a single
certificate) using the certificate reply and trusted certificates
that are already available in the keystore where you import the
reply or in the "cacerts" keystore file.</p>
<p>For example, suppose you sent your certificate signing request
to VeriSign. You can then import the reply via the following, which
assumes the returned certificate is named "VSMarkJ.cer":</p>
<pre class="codeblock">
    keytool -importcert -trustcacerts -file VSMarkJ.cer
</pre>
<h3>Exporting a Certificate Authenticating Your Public Key</h3>
<p>Suppose you have used the <a href="jarsigner.html">jarsigner</a>
tool to sign a Java ARchive (JAR) file. Clients that want to use
the file will want to authenticate your signature.</p>
<p>One way they can do this is by first importing your public key
certificate into their keystore as a "trusted" entry. You can
export the certificate and supply it to your clients. As an
example, you can copy your certificate to a file named
<code>MJ.cer</code> via the following, assuming the entry is
aliased by "mykey":</p>
<pre class="codeblock">
    keytool -exportcert -alias mykey -file MJ.cer
</pre>
<p>Given that certificate, and the signed JAR file, a client can
use the <b>jarsigner</b> tool to authenticate your signature.</p>
<!--h3>Changing Your Distinguished Name but Keeping your Key Pair</h3>



Suppose your distinguished name changes, for example because you have
changed departments or moved to a different city. If desired, you may
still use the public/private key pair you've previously used, and yet
update your distinguished name. For example, suppose your name is
Susan Miller, and you created your initial key entry with
the alias <code>sMiller</code> and the distinguished name

<pre class="codeblock">
  "cn=Susan Miller, ou=Finance Department, o=BlueSoft, c=us"
</pre>

Suppose you change from the Finance Department to the Accounting Department.
You can still use the previously-generated public/private key pair
and yet update your distinguished name by doing the following.

First, copy (clone) your key entry:

<pre class="codeblock">
    keytool -keyclone -alias sMiller -dest sMillerNew
</pre>

(This prompts for the store password and for the
initial and destination private key
passwords, since they aren't provided at the command line.)
Now you need to change the certificate chain associated with
the copy, so that the first certificate in the chain uses your
different distinguished name. Start by generating a self-signed
certificate with the appropriate name:

<pre class="codeblock">
    keytool -selfcert -alias sMillerNew
      -dname "cn=Susan Miller, ou=Accounting Department, o=BlueSoft, c=us"
</pre>

<p>Then generate a Certificate Signing Request based on the information
in this new certificate:

</p>
<pre class="codeblock">
    keytool -certreq -alias sMillerNew
</pre>

When you get the CA certificate reply, import it:

<pre class="codeblock">
    keytool -import -alias sMillerNew -file VSSMillerNew.cer
</pre>

After importing the certificate reply, you may want to remove the
initial key entry that used your old distinguished name:

<pre class="codeblock">
    keytool -delete -alias sMiller
</pre>


-->
<h3>Importing Keystore</h3>
<p>The command "importkeystore" is used to import an entire
keystore into another keystore, which means all entries from the
source keystore, including keys and certificates, are all imported
to the destination keystore within a single command. You can use
this command to import entries from a different type of keystore.
During the import, all new entries in the destination keystore will
have the same alias names and protection passwords (for secret keys
and private keys). If <b>keytool</b> has difficulties recover the
private keys or secret keys from the source keystore, it will
prompt you for a password. If it detects alias duplication, it will
ask you for a new one, you can specify a new alias or simply allow
<b>keytool</b> to overwrite the existing one.</p>
<p>For example, to import entries from a normal JKS type keystore
key.jks into a PKCS #11 type hardware based keystore, you can use
the command:</p>
<pre class="codeblock">
  keytool -importkeystore
    -srckeystore key.jks -destkeystore NONE
    -srcstoretype JKS -deststoretype PKCS11
    -srcstorepass <em>&lt;source keystore password&gt;</em> -deststorepass <em>&lt;destination keystore password&gt;</em>
</pre>
<p>The importkeystore command can also be used to import a single
entry from a source keystore to a destination keystore. In this
case, besides the options you see in the above example, you need to
specify the alias you want to import. With the srcalias option
given, you can also specify the destination alias name in the
command line, as well as protection password for a secret/private
key and the destination protection password you want. The following command demonstrates this:</p>
<pre class="codeblock">
  keytool -importkeystore
    -srckeystore key.jks -destkeystore NONE
    -srcstoretype JKS -deststoretype PKCS11
    -srcstorepass <em>&lt;source keystore password&gt;</em> -deststorepass <em>&lt;destination keystore password&gt;</em>
    -srcalias myprivatekey -destalias myoldprivatekey
    -srckeypass <em>&lt;source entry password&gt;</em> -destkeypass <em>&lt;destination entry password&gt;</em>
    -noprompt
</pre>
<h3>Generating Certificates for a Typical SSL Server</h3>
<p>The following are keytool commands to generate keypairs and
certificates for three entities, namely, Root CA (root),
Intermediate CA (ca), and SSL server (server). Ensure that you
store all the certificates in the same keystore. In these examples,
it is recommended that you specify RSA as the key algorithm.</p>
<pre class="codeblock">
keytool -genkeypair -keystore root.jks -alias root -ext bc:c
keytool -genkeypair -keystore ca.jks -alias ca -ext bc:c
keytool -genkeypair -keystore server.jks -alias server

keytool -keystore root.jks -alias root -exportcert -rfc &gt; root.pem

keytool -storepass <em>&lt;storepass&gt;</em> -keystore ca.jks -certreq -alias ca | keytool -storepass <em>&lt;storepass&gt;</em> -keystore root.jks -gencert -alias root -ext BC=0 -rfc &gt; ca.pem
keytool -keystore ca.jks -importcert -alias ca -file ca.pem

keytool -storepass <em>&lt;storepass&gt;</em> -keystore server.jks -certreq -alias server | keytool -storepass <em>&lt;storepass&gt;</em> -keystore ca.jks -gencert -alias ca -ext ku:c=dig,kE -rfc &gt; server.pem
cat root.pem ca.pem server.pem | keytool -keystore server.jks -importcert -alias server
</pre>
<h2>TERMINOLOGY and WARNINGS</h2>
<a name="KeyStore" id="KeyStore"></a>
<h3>KeyStore</h3>
<p>A keystore is a storage facility for cryptographic keys and
certificates.</p>
<ul>
<li>
<h4><a name="KeyStoreEntries" id="KeyStoreEntries">KeyStore
Entries</a></h4>
<p>Keystores may have different types of entries. The two most
applicable entry types for <b>keytool</b> include:</p>
<ol>
<li><b>key entries</b> - each holds very sensitive cryptographic
key information, which is stored in a protected format to prevent
unauthorized access. Typically, a key stored in this type of entry
is a secret key, or a private key accompanied by the <a href=
"#CertChains">certificate "chain"</a> for the corresponding public
key. The <b>keytool</b> can handle both types of entries, while the
<b>jarsigner</b> tool only handle the latter type of entry, that is
private keys and their associated certificate chains.</li>
<li><b>trusted certificate entries</b> - each contains a single
public key certificate belonging to another party. It is called a
"trusted certificate" because the keystore owner trusts that the
public key in the certificate indeed belongs to the identity
identified by the "subject" (owner) of the certificate. The issuer
of the certificate vouches for this, by signing the
certificate.</li>
</ol>
</li>
<li>
<h4><a name="KeyStoreAliases" id="KeyStoreAliases">KeyStore
Aliases</a></h4>
<p>All keystore entries (key and trusted certificate entries) are
accessed via unique <i>aliases</i>.</p>
<p>An alias is specified when you add an entity to the keystore
using the <a href="#genseckeyCmd">-genseckey</a> command to
generate a secret key, <a href="#genkeypairCmd">-genkeypair</a>
command to generate a key pair (public and private key) or the
<a href="#importCertCmd">-importcert</a> command to add a
certificate or certificate chain to the list of trusted
certificates. Subsequent <b>keytool</b> commands must use this same
alias to refer to the entity.</p>
<p>For example, suppose you use the alias <tt>duke</tt> to generate
a new public/private key pair and wrap the public key into a
self-signed certificate (see <a href="#CertChains">Certificate
Chains</a>) via the following command:</p>
<pre class="codeblock">
    keytool -genkeypair -alias duke -keypass dukekeypasswd
</pre>
<p>This specifies an initial password of "dukekeypasswd" required
by subsequent commands to access the private key associated with
the alias <code>duke</code>. If you later want to change duke's
private key password, you use a command like the following:</p>
<pre class="codeblock">
    keytool -keypasswd -alias duke -keypass dukekeypasswd -new newpass
</pre>
<p>This changes the password from "dukekeypasswd" to "newpass".</p>
<p>Please note: A password should not actually be specified on a
command line or in a script unless it is for testing purposes, or
you are on a secure system. If you don't specify a required
password option on a command line, you will be prompted for it.</p>
</li>
<!-- ********************************** -->
<li>
<h4><a name="KeyStoreImplementation" id=
"KeyStoreImplementation">KeyStore Implementation</a></h4>
<p>The <code>KeyStore</code> class provided in the
<code>java.security</code> package supplies well-defined interfaces
to access and modify the information in a keystore. It is possible
for there to be multiple different concrete implementations, where
each implementation is that for a particular <i>type</i> of
keystore.</p>
<p>Currently, two command-line tools (<b>keytool</b> and
<b>jarsigner</b>) and a GUI-based tool named <b>Policy Tool</b>
make use of keystore implementations. Since <code>KeyStore</code>
is publicly available, users can write additional security
applications that use it.</p>
<p>There is a built-in default implementation, provided by Oracle.
It implements the keystore as a file, utilizing a proprietary
keystore type (format) named "JKS". It protects each private key
with its individual password, and also protects the integrity of
the entire keystore with a (possibly different) password.</p>
<p>Keystore implementations are provider-based. More specifically,
the application interfaces supplied by <code>KeyStore</code> are
implemented in terms of a "Service Provider Interface" (SPI). That
is, there is a corresponding abstract <code>KeystoreSpi</code>
class, also in the <code>java.security</code> package, which
defines the Service Provider Interface methods that "providers"
must implement. (The term "provider" refers to a package or a set
of packages that supply a concrete implementation of a subset of
services that can be accessed by the Java Security API.) Thus, to
provide a keystore implementation, clients must implement a
"provider" and supply a KeystoreSpi subclass implementation, as
described in <a href=
"../../guides/security/crypto/HowToImplAProvider.html">How to
Implement a Provider for the Java Cryptography
Architecture</a>.</p>
<p>Applications can choose different <i>types</i> of keystore
implementations from different providers, using the "getInstance"
factory method supplied in the <code>KeyStore</code> class. A
keystore type defines the storage and data format of the keystore
information, and the algorithms used to protect private/secret keys
in the keystore and the integrity of the keystore itself. Keystore
implementations of different types are not compatible.</p>
<p><b>keytool</b> works on any file-based keystore implementation.
(It treats the keystore location that is passed to it at the
command line as a filename and converts it to a FileInputStream,
from which it loads the keystore information.) The <b>jarsigner</b>
and <b>policytool</b> tools, on the other hand, can read a keystore
from any location that can be specified using a URL.</p>
<p>For <b>keytool</b> and <b>jarsigner</b>, you can specify a
keystore type at the command line, via the <i>-storetype</i>
option. For <b>Policy Tool</b>, you can specify a keystore type via
the "Keystore" menu.</p>
<p>If you don't explicitly specify a keystore type, the tools
choose a keystore implementation based simply on the value of the
<code>keystore.type</code> property specified in the security
properties file. The security properties file is called
<tt>java.security</tt>, and it resides in the security properties
directory, <code><i>java.home</i>\lib\security</code>, where
<i>java.home</i> is the runtime environment's directory (the
<tt>jre</tt> directory in the SDK or the top-level directory of the
Java 2 Runtime Environment).</p>
<!-- ******************* -->
<p>Each tool gets the <code>keystore.type</code> value and then
examines all the currently-installed providers until it finds one
that implements keystores of that type. It then uses the keystore
implementation from that provider.</p>
<p>The <code>KeyStore</code> class defines a static method named
<code>getDefaultType</code> that lets applications and applets
retrieve the value of the <code>keystore.type</code> property. The
following line of code creates an instance of the default keystore
type (as specified in the <code>keystore.type</code> property):</p>
<pre class="codeblock">
    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
</pre>
<p>The default keystore type is "jks" (the proprietary type of the
keystore implementation provided by Oracle). This is specified by
the following line in the security properties file:</p>
<pre class="codeblock">
    keystore.type=jks
</pre>
<p>To have the tools utilize a keystore implementation other than
the default, you can change that line to specify a different
keystore type.</p>
<p>For example, if you have a provider package that supplies a
keystore implementation for a keystore type called "pkcs12", change
the line to</p>
<pre class="codeblock">
    keystore.type=pkcs12
</pre>
<p>Note: case doesn't matter in keystore type designations. For
example, "JKS" would be considered the same as "jks".</p>
</li>
</ul>
<h3><a name="Certificates" id="Certificates">Certificate</a></h3>
A <b>certificate</b> (also known as a <b>public-key
certificate</b>) is a digitally signed statement from one entity
(the <i>issuer</i>), saying that the public key (and some other
information) of another entity (the <i>subject</i>) has some
specific value.
<ul>
<li><a name="CertificateTerms" id="CertificateTerms"></a>
<h4>Certificate Terms</h4>
<dl>
<dt><i>Public Keys</i></dt>
<dd>
<p>These are numbers associated with a particular entity, and are
intended to be known to everyone who needs to have trusted
interactions with that entity. Public keys are used to verify
signatures.</p>
</dd>
<dt><i>Digitally Signed</i></dt>
<dd>
<p>If some data is <i>digitally signed</i> it has been stored with
the "identity" of an entity, and a signature that proves that
entity knows about the data. The data is rendered unforgeable by
signing with the entity's private key.</p>
</dd>
<dt><i>Identity</i></dt>
<dd>
<p>A known way of addressing an entity. In some systems the
identity is the public key, in others it can be anything from a
Unix UID to an Email address to an X.509 Distinguished Name.</p>
</dd>
<dt><i>Signature</i></dt>
<dd>
<p>A signature is computed over some data using the private key of
an entity (the <i>signer</i>, which in the case of a certificate is
also known as the <i>issuer</i>).</p>
</dd>
<dt><i>Private Keys</i></dt>
<dd>
<p>These are numbers, each of which is supposed to be known only to
the particular entity whose private key it is (that is, it's
supposed to be kept secret). Private and public keys exist in pairs
in all public key cryptography systems (also referred to as "public
key crypto systems"). In a typical public key crypto system, such
as DSA, a private key corresponds to exactly one public key.
Private keys are used to compute signatures.</p>
</dd>
<dt><i>Entity</i></dt>
<dd>
<p>An entity is a person, organization, program, computer,
business, bank, or something else you are trusting to some
degree.</p>
</dd>
</dl>
<p>Basically, public key cryptography requires access to users'
public keys. In a large-scale networked environment it is
impossible to guarantee that prior relationships between
communicating entities have been established or that a trusted
repository exists with all used public keys. Certificates were
invented as a solution to this public key distribution problem. Now
a <i>Certification Authority</i> (CA) can act as a trusted third
party. CAs are entities (for example, businesses) that are trusted
to sign (issue) certificates for other entities. It is assumed that
CAs will only create valid and reliable certificates, as they are
bound by legal agreements. There are many public Certification
Authorities, such as <a href=
"http://www.verisign.com/">VeriSign</a>, <a href=
"http://www.thawte.com/">Thawte</a>, <a href=
"http://www.entrust.com/">Entrust</a>, and so on. You can also run
your own Certification Authority using products such as Microsoft
Certificate Server or the Entrust CA product for your
organization.</p>
<p>Using <b>keytool</b>, it is possible to display, import, and
export certificates. It is also possible to generate self-signed
certificates.</p>
<p><b>keytool</b> currently handles X.509 certificates.</p>
<a name="X509Cert" id="X509Cert"></a></li>
<li>
<h4>X.509 Certificates</h4>
<p>The X.509 standard defines what information can go into a
certificate, and describes how to write it down (the data format).
All the data in a certificate is encoded using two related
standards called ASN.1/DER. <i>Abstract Syntax Notation 1</i>
describes data. The <i>Definite Encoding Rules</i> describe a
single way to store and transfer that data.</p>
<p>All X.509 certificates have the following data, in addition to
the signature:</p>
<dl>
<dt><i>Version</i></dt>
<dd>
<p>This identifies which version of the X.509 standard applies to
this certificate, which affects what information can be specified
in it. Thus far, three versions are defined. <b>keytool</b> can
import and export v1, v2, and v3 certificates. It generates v3
certificates.</p>
<p><i>X.509 Version 1</i> has been available since 1988, is widely
deployed, and is the most generic.</p>
<p><i>X.509 Version 2</i> introduced the concept of subject and
issuer unique identifiers to handle the possibility of reuse of
subject and/or issuer names over time. Most certificate profile
documents strongly recommend that names not be reused, and that
certificates should not make use of unique identifiers. Version 2
certificates are not widely used.</p>
<p><i>X.509 Version 3</i> is the most recent (1996) and supports
the notion of extensions, whereby anyone can define an extension
and include it in the certificate. Some common extensions in use
today are: <i>KeyUsage</i> (limits the use of the keys to
particular purposes such as "signing-only") and
<i>AlternativeNames</i> (allows other identities to also be
associated with this public key, e.g. DNS names, Email addresses,
IP addresses). Extensions can be marked <i>critical</i> to indicate
that the extension should be checked and enforced/used. For
example, if a certificate has the KeyUsage extension marked
critical and set to "keyCertSign" then if this certificate is
presented during SSL communication, it should be rejected, as the
certificate extension indicates that the associated private key
should only be used for signing certificates and not for SSL
use.</p>
</dd>
<dt><i>Serial Number</i></dt>
<dd>
<p>The entity that created the certificate is responsible for
assigning it a serial number to distinguish it from other
certificates it issues. This information is used in numerous ways,
for example when a certificate is revoked its serial number is
placed in a Certificate Revocation List (CRL).</p>
</dd>
<dt><i>Signature Algorithm Identifier</i></dt>
<dd>
<p>This identifies the algorithm used by the CA to sign the
certificate.</p>
</dd>
<dt><i>Issuer Name</i></dt>
<dd>
<p>The <a href="#DName">X.500 Distinguished Name</a> of the entity
that signed the certificate. This is normally a CA. Using this
certificate implies trusting the entity that signed this
certificate. (Note that in some cases, such as <i>root or
top-level</i> CA certificates, the issuer signs its own
certificate.)</p>
</dd>
<dt><i>Validity Period</i></dt>
<dd>
<p>Each certificate is valid only for a limited amount of time.
This period is described by a start date and time and an end date
and time, and can be as short as a few seconds or almost as long as
a century. The validity period chosen depends on a number of
factors, such as the strength of the private key used to sign the
certificate or the amount one is willing to pay for a certificate.
This is the expected period that entities can rely on the public
value, if the associated private key has not been compromised.</p>
</dd>
<dt><i>Subject Name</i></dt>
<dd>
<p>The name of the entity whose public key the certificate
identifies. This name uses the X.500 standard, so it is intended to
be unique across the Internet. This is the <a href="#DName">X.500
Distinguished Name</a> (DN) of the entity, for example,</p>
<pre class="codeblock">
    CN=Java Duke, OU=Java Software Division, O=Oracle Corporation, C=US
</pre>
<p>(These refer to the subject's Common Name, Organizational Unit,
Organization, and Country.)</p>
</dd>
<dt><i>Subject Public Key Information</i></dt>
<dd>
<p>This is the public key of the entity being named, together with
an algorithm identifier which specifies which public key crypto
system this key belongs to and any associated key parameters.</p>
</dd>
</dl>
<a name="CertChains" id="CertChains"></a></li>
<li>
<h4>Certificate Chains</h4>
<p><b>keytool</b> can create and manage keystore "key" entries that
each contain a private key and an associated certificate "chain".
The first certificate in the chain contains the public key
corresponding to the private key.</p>
<p>When keys are first generated (see the <a href=
"#genkeypairCmd">-genkeypair</a> command), the chain starts off
containing a single element, a <i>self-signed certificate</i>. A
self-signed certificate is one for which the issuer (signer) is the
same as the subject (the entity whose public key is being
authenticated by the certificate). Whenever the
<code>-genkeypair</code> command is called to generate a new
public/private key pair, it also wraps the public key into a
self-signed certificate.</p>
<p>Later, after a Certificate Signing Request (CSR) has been
generated (see the <a href="#certreqCmd">-certreq</a> command) and
sent to a Certification Authority (CA), the response from the CA is
imported (see <a href="#importCertCmd">-importcert</a>), and the
self-signed certificate is replaced by a chain of certificates. At
the bottom of the chain is the certificate (reply) issued by the CA
authenticating the subject's public key. The next certificate in
the chain is one that authenticates the <i>CA</i>'s public key.</p>
<p>In many cases, this is a self-signed certificate (that is, a
certificate from the CA authenticating its own public key) and the
last certificate in the chain. In other cases, the CA may return a
chain of certificates. In this case, the bottom certificate in the
chain is the same (a certificate signed by the CA, authenticating
the public key of the key entry), but the second certificate in the
chain is a certificate signed by a <i>different</i> CA,
authenticating the public key of the CA you sent the CSR to. Then,
the next certificate in the chain will be a certificate
authenticating the second CA's key, and so on, until a self-signed
"root" certificate is reached. Each certificate in the chain (after
the first) thus authenticates the public key of the signer of the
previous certificate in the chain.</p>
<p>Many CAs only return the issued certificate, with no supporting
chain, especially when there is a flat hierarchy (no intermediates
CAs). In this case, the certificate chain must be established from
trusted certificate information already stored in the keystore.</p>
<p>A different reply format (defined by the PKCS#7 standard) also
includes the supporting certificate chain, in addition to the
issued certificate. Both reply formats can be handled by
<b>keytool</b>.</p>
<p>The top-level (root) CA certificate is self-signed. However, the
trust into the root's public key does not come from the root
certificate itself (anybody could generate a self-signed
certificate with the distinguished name of say, the VeriSign root
CA!), but from other sources like a newspaper. The root CA public
key is widely known. The only reason it is stored in a certificate
is because this is the format understood by most tools, so the
certificate in this case is only used as a "vehicle" to transport
the root CA's public key. Before you add the root CA certificate to
your keystore, you should view it (using the
<code>-printcert</code> option) and compare the displayed
fingerprint with the well-known fingerprint (obtained from a
newspaper, the root CA's Web page, etc.).</p>
<a name="cacerts" id="cacerts"></a></li>
<!-- ********************** -->
<li>
<h4>The cacerts Certificates File</h4>
<p>A certificates file named <b>"cacerts"</b> resides in the
security properties directory,
<code><i>java.home</i>\lib\security</code>, where <i>java.home</i>
is the runtime environment's directory (the <tt>jre</tt> directory
in the SDK or the top-level directory of the Java 2 Runtime
Environment).</p>
<!-- ************************** -->
<p>The "cacerts" file represents a system-wide keystore with CA
certificates. System administrators can configure and manage that
file using <b>keytool</b>, specifying "jks" as the keystore type.
The "cacerts" keystore file ships with a default set of root CA
certificates; list them with the following command:</p>
<pre class="codeblock">
keytool -list -keystore <em>java.home</em>\lib\security\cacerts
</pre>
<p>The initial password of the "cacerts" keystore file is
"changeit". System administrators should change that password and
the default access permission of that file upon installing the
SDK.</p>
<p><b>IMPORTANT: Verify Your <code>cacerts</code> File</b>: Since
you trust the CAs in the <code>cacerts</code> file as entities for
signing and issuing certificates to other entities, you must manage
the <code>cacerts</code> file carefully. The <code>cacerts</code>
file should contain only certificates of the CAs you trust. It is
your responsibility to verify the trusted root CA certificates
bundled in the <code>cacerts</code> file and make your own trust
decisions. To remove an untrusted CA certificate from the
<code>cacerts</code> file, use the delete option of the
<code>keytool</code> command. You can find the <code>cacerts</code>
file in the JRE installation directory. Contact your system
administrator if you do not have permission to edit this file.</p>
<a name="EncodeCertificate" id="EncodeCertificate"></a></li>
<li>
<h4>The Internet RFC 1421 Certificate Encoding Standard</h4>
<p>Certificates are often stored using the printable encoding
format defined by the Internet RFC 1421 standard, instead of their
binary encoding. This certificate format, also known as "Base 64
encoding", facilitates exporting certificates to other applications
by email or through some other mechanism.</p>
<p>Certificates read by the <code>-importcert</code> and
<code>-printcert</code> commands can be in either this format or
binary encoded.</p>
<p>The <code>-exportcert</code> command by default outputs a
certificate in binary encoding, but will instead output a
certificate in the printable encoding format, if the
<code>-rfc</code> option is specified.</p>
<p>The <code>-list</code> command by default prints the SHA1
fingerprint of a certificate. If the <code>-v</code> option is
specified, the certificate is printed in human-readable format,
while if the <code>-rfc</code> option is specified, the certificate
is output in the printable encoding format.</p>
<p>In its printable encoding format, the encoded certificate is
bounded at the beginning by</p>
<pre class="codeblock">
-----BEGIN CERTIFICATE-----
</pre>
<p>and at the end by</p>
<pre class="codeblock">
-----END CERTIFICATE-----
</pre></li>
</ul>
<a name="DName" id="DName"></a>
<h3>X.500 Distinguished Names</h3>
<p>X.500 Distinguished Names are used to identify entities, such as
those which are named by the <code>subject</code> and
<code>issuer</code> (signer) fields of X.509 certificates.
<b>keytool</b> supports the following subparts:</p>
<ul>
<li><i>commonName</i> - common name of a person, e.g., "Susan
Jones"</li>
<li><i>organizationUnit</i> - small organization (e.g., department
or division) name, e.g., "Purchasing"</li>
<li><i>organizationName</i> - large organization name, e.g.,
"ABCSystems, Inc."</li>
<li><i>localityName</i> - locality (city) name, e.g., "Palo
Alto"</li>
<li><i>stateName</i> - state or province name, e.g.,
"California"</li>
<li><i>country</i> - two-letter country code, e.g., "CH"</li>
</ul>
<p>When supplying a distinguished name string as the value of a
<code>-dname</code> option, as for the <code>-genkeypair</code>
<!--or
<code>-selfcert</code--> command<!--s-->, the string must be in the
following format:</p>
<pre class="codeblock">
CN=<i>cName</i>, OU=<i>orgUnit</i>, O=<i>org</i>, L=<i>city</i>, S=<i>state</i>, C=<i>countryCode</i>
</pre>
<p>where all the italicized items represent actual values and the
above keywords are abbreviations for the following:</p>
<pre class="codeblock">
        CN=commonName
        OU=organizationUnit
        O=organizationName
        L=localityName
        S=stateName
        C=country
</pre>
<p>A sample distinguished name string is</p>
<pre class="codeblock">
CN=Mark Smith, OU=Java, O=Oracle, L=Cupertino, S=California, C=US
</pre>
<p>and a sample command using such a string is</p>
<pre class="codeblock">
keytool -genkeypair -dname "CN=Mark Smith, OU=Java, O=Oracle, L=Cupertino,
S=California, C=US" -alias mark
</pre>
<p>Case does not matter for the keyword abbreviations. For example,
"CN", "cn", and "Cn" are all treated the same.</p>
<p>Order matters; each subcomponent must appear in the designated
order. However, it is not necessary to have all the subcomponents.
You may use a subset, for example:</p>
<pre class="codeblock">
CN=Steve Meier, OU=Java, O=Oracle, C=US
</pre>
<p>If a distinguished name string value contains a comma, the comma
must be escaped by a "\" character when you specify the string on a
command line, as in</p>
<pre class="codeblock">
   cn=Peter Schuster, ou=Java\, Product Development, o=Oracle, c=US
</pre>
<p>It is never necessary to specify a distinguished name string on
a command line. If it is needed for a command, but not supplied on
the command line, the user is prompted for each of the
subcomponents. In this case, a comma does not need to be escaped by
a "\".</p>
<!-- ******************** -->
<a name="TrustedCertWarning" id="TrustedCertWarning"></a>
<h3>WARNING Regarding Importing Trusted Certificates</h3>
<p>IMPORTANT: Be sure to check a certificate very carefully before
importing it as a trusted certificate!</p>
<p>View it first (using the <code>-printcert</code> command, or the
<code>-importcert</code> command without the <code>-noprompt</code>
option), and make sure that the displayed certificate
fingerprint(s) match the expected ones. For example, suppose
someone sends or emails you a certificate, and you put it in a file
named <code>C:\temp\cert</code>. Before you consider adding the
certificate to your list of trusted certificates, you can execute a
<code>-printcert</code> command to view its fingerprints, as in</p>
<pre class="codeblock">
  keytool -printcert -file C:\temp\cert
    Owner: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
    Issuer: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
    Serial Number: 59092b34
    Valid from: Thu Sep 25 18:01:13 PDT 1997 until: Wed Dec 24 17:01:13 PST 1997
    Certificate Fingerprints:
         MD5:  11:81:AD:92:C8:E5:0E:A2:01:2E:D4:7A:D7:5F:07:6F
         SHA1: 20:B6:17:FA:EF:E5:55:8A:D0:71:1F:E8:D6:9D:C0:37:13:0E:5E:FE
         SHA256: 90:7B:70:0A:EA:DC:16:79:92:99:41:FF:8A:FE:EB:90:
                 17:75:E0:90:B2:24:4D:3A:2A:16:A6:E4:11:0F:67:A4
</pre>
<p>Then call or otherwise contact the person who sent the
certificate, and compare the fingerprint(s) that you see with the
ones that they show. Only if the fingerprints are equal is it
guaranteed that the certificate has not been replaced in transit
with somebody else's (for example, an attacker's) certificate. If
such an attack took place, and you did not check the certificate
before you imported it, you would end up trusting anything the
attacker has signed (for example, a JAR file with malicious class
files inside).</p>
<p>Note: it is not required that you execute a
<code>-printcert</code> command prior to importing a certificate,
since before adding a certificate to the list of trusted
certificates in the keystore, the <code>-importcert</code> command
prints out the certificate information and prompts you to verify
it. You then have the option of aborting the import operation.
Note, however, this is only the case if you invoke the
<code>-importcert</code> command without the <code>-noprompt</code>
option. If the <code>-noprompt</code> option is given, there is no
interaction with the user.</p>
<a name="PasswordWarning" id="PasswordWarning"></a>
<h3>Warning Regarding Passwords</h3>
<p>Most commands operating on a keystore require the store
password. Some commands require a private/secret key password.</p>
<p>Passwords can be specified on the command line (in the
<code>-storepass</code> and <code>-keypass</code> options,
respectively). However, a password should not be specified on a
command line or in a script unless it is for testing purposes, or
you are on a secure system.</p>
<p>If you don't specify a required password option on a command
line, you will be prompted for it.</p>
<a name="gencertwarning" id="gencertwarning"></a>
<h3>Warning Regarding Certificate Conformance</h3>
<p>The Internet standard <a href=
"http://tools.ietf.org/rfc/rfc5280.txt">RFC 5280</a> has defined a
profile on conforming X.509 certificates, which includes what
values and value combinations are valid for certificate fields and
extensions. <b>keytool</b> has not enforced all these rules so it
can generate certificates which do not conform to the standard, and
these certificates might be rejected by JRE or other applications.
Users should make sure that they provide the correct options for
<code>-dname</code>, <code>-ext</code>, etc.</p>
<h2><a name="SeeAlso" id="SeeAlso">SEE ALSO</a></h2>
<ul>
<li><a href="jar.html">jar</a> tool documentation</li>
<li><a href="jarsigner.html">jarsigner</a> tool documentation</li>
<li>the <a href=
"http://docs.oracle.com/javase/tutorial/security/index.html"><b>Security</b></a>
trail of the <a href=
"http://docs.oracle.com/javase/tutorial/"><b>Java Tutorial</b></a>
for examples of the use of <b>keytool</b></li>
</ul>
<h2><a name="Changes" id="Changes">CHANGES</a></h2>
<p>The command interface for keytool changed in Java SE 6.</p>
<p><b>keytool</b> no longer displays password input when entered by
users. Since password input can no longer be viewed when entered,
users will be prompted to re-enter passwords any time a password is
being set or changed (for example, when setting the initial
keystore password, or when changing a key password).</p>
<p>Some commands have simply been renamed, and other commands
deemed obsolete are no longer listed in this document. All previous
commands (both renamed and obsolete) are still supported in this
release and will continue to be supported in future releases. The
following summarizes all of the changes made to the keytool command
interface:</p>
<p>Renamed commands:</p>
<ul>
<li><code>-export</code>, renamed to <a href=
"#exportCertCmd"><code>-exportcert</code></a></li>
<li><code>-genkey</code>, renamed to <a href=
"#genkeypairCmd"><code>-genkeypair</code></a></li>
<li><code>-import</code>, renamed to <a href=
"#importCertCmd"><code>-importcert</code></a></li>
</ul>
<p>Commands deemed obsolete and no longer documented:</p>
<ul>
<li><a href="http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/keytool.html#keycloneCmd">
<code>-keyclone</code></a></li>
<li><a href="http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/keytool.html#identitydbCmd">
<code>-identitydb</code></a></li>
<li><a href="http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/keytool.html#selfcertCmd">
<code>-selfcert</code></a></li>
</ul>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2012, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
